import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());
    
    // For generating compile error token


    private ComplexSymbolFactory symbolFactory = new ComplexSymbolFactory();

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                //String text = ((ChocoPyLexer) getScanner()).yytext();
                String text = cur_token.value.toString();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }
    
    public void syntax_error(Symbol cur_token, String reasons) {
                String token = symbl_name_from_id(cur_token.sym);
                //String text = ((ChocoPyLexer) getScanner()).yytext();
                String text = cur_token.value.toString();
                if(reasons != null){
                  text = text + '\n' + reasons;
                }
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ...
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;

            
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node last = nodes.get(nodes.size()-1);
        return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                 last.getLocation()[3]);
    }

:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */
    
    // Some Ideas were taken from https://github.com/Leo-Enrique-Wu/chocopy_compiler_parser 


 /* These are the symbols list, here terminal is tokens for operators and symbols, keywords, identifier.*/
/*Conditional Statements*/
terminal IF, ELIF, ELSE, WHILE;

/*Loop Utils*/
terminal BREAK, CONTINUE, PASS, RETURN;
terminal FOR;
terminal IN;

/*Comparisons */
terminal String AND, OR;
terminal ASSERT, EXCEPT, RAISE, TRY;

/* Booleans, Negations, Nulls*/
terminal boolean TRUE, FALSE;
terminal NONE;
terminal String NOT;

/* class and functional terms and variables*/
terminal CLASS;
terminal DEF;
terminal GLOBAL;
terminal IMPORT;
terminal NONLOCAL;
terminal LAMBDA;
terminal YIELD;

/* Indentations*/
terminal INDENT;
terminal DEDENT;

/* operators*/
terminal String PLUS;
terminal String MINUS;
terminal String MULT;
terminal String DIV;
terminal String MOD;
terminal String GT;
terminal String LT;
terminal String GE;
terminal String LE;
terminal String EQEQ;
terminal String NEQ;
terminal String EQ;

/* Brackets, Parenthesis, Comma, Colons*/
terminal String LPAREN;
terminal String RPAREN;
terminal String COMMA;
terminal String COLON;
terminal String DOT;

/* Variable Types*/
terminal String STRING;
terminal Integer INTEGER;
terminal String IDENTIFIER;
terminal String IDSTRING;

/* Miscellaneous */
terminal String LINDEX;
terminal String RINDEX;
terminal String ARROW;
terminal String AS, IS;
terminal WITH;
terminal FROM;
terminal ASYNC, AWAIT;
terminal DEL;
terminal FINALLY;
terminal NEWLINE;

/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
terminal UNRECOGNIZED;

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols,
 *     non terminal <type> <identifier1>, ..., <identifiern>;
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */
non terminal Program           program;
non terminal List<Declaration> program_defs, opt_declare_list, class_declare;
non terminal List<Stmt>        stmt_list, statements, block, elif_optional_list;
non terminal List<Expr>        expr_list, assign_targets;
non terminal List<TypedVar>    typedvar_list;
non terminal Stmt              stmt, expr_stmt, assign_stmt, smpl_statement;
non terminal Expr              expr, binary_expr, tempexpr, cexpr;
non terminal FuncDef           func_def;
non terminal ClassDef          class_def;
non terminal TypeAnnotation    type;
non terminal Declaration       declare;
non terminal TypedVar          typedvar;
non terminal Literal           literal;
non terminal Identifier        identifier;
non terminal VarDef            var_def;
non terminal MemberExpr        member_expr;
non terminal IndexExpr         index_expr;

/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */
precedence right IF, ELSE, ELIF;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc LT, GT, LE, GE, EQEQ, NEQ, IS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left DOT, LINDEX, RINDEX;

/* The start symbol. */
start with program;



/*****  GRAMMAR RULES *****/


/*   


program -> program_defs* statement*

where programs defs [class_defs | func_defs | var_defs]

 */ 


program ::= program_defs:def statements:s
        {: 
           
            
            if (def.isEmpty()){
                RESULT=new Program(getLeft(s),sxright,def,s,errors);
            }
            else{
                RESULT=new Program(getLeft(def),sxright,def,s,errors);

            }

            
         :}
        ;


program_defs ::= program_defs:head var_def:curr_var_def   {: RESULT = combine(head,curr_var_def); :}
               |program_defs:head class_def:curr_class_def {: RESULT = combine(head,curr_class_def); :} 
               |program_defs:head func_def:curr_fun_def  {: RESULT = combine(head,curr_fun_def); :} 
               |{: RESULT = empty(); :}
               ;

statements ::=  {: RESULT = empty(); :}
                | stmt_list:curr_stmt        {: RESULT = curr_stmt; :}
                ;


stmt_list ::= error {: RESULT = empty(); :}
            |stmt_list:curr_stmt_lst stmt:curr_stmt {: RESULT = combine(curr_stmt_lst, curr_stmt); :} 
            |   stmt:curr_stmt  {: RESULT = single(curr_stmt); :}
            | stmt_list:curr_stmt_lst error {: RESULT = curr_stmt_lst; :}
            ;


/* Grammar of class_defs, func_defs,var_defs */    
var_def ::= typedvar:curr_typed_var EQ literal:curr_literal NEWLINE
                {: RESULT = new VarDef(curr_typed_varxleft,curr_literalxright,curr_typed_var,curr_literal); :}
          ;


class_def ::= CLASS:curr_class identifier:curr_id1 LPAREN identifier:curr_id2 RPAREN COLON NEWLINE INDENT PASS NEWLINE:new_line DEDENT:dedent
                    {: RESULT = new ClassDef(curr_classxleft,new_linexright,curr_id1,curr_id2,empty()); :} 
             |CLASS:curr_class identifier:curr_id1 LPAREN identifier:curr_id2 RPAREN COLON NEWLINE INDENT class_declare:class_declaration DEDENT:dedent
                    {: RESULT = new ClassDef(curr_classxleft,class_declarationxright,curr_id1,curr_id2,class_declaration); :} 
            ;


func_def ::= DEF:curr_def identifier:identifier_1 LPAREN typedvar_list:typedvar_1 RPAREN COLON:colon_1 NEWLINE:new_line_1 INDENT opt_declare_list:dec_list stmt_list:st_list_1 DEDENT:dedent
                            {: ClassType re_none = new ClassType(colon_1xright,colon_1xright,"<None>"); 
                                RESULT = new FuncDef(curr_defxleft,getRight(st_list_1),identifier_1,typedvar_1,re_none,dec_list,st_list_1); 
                            :}
           | DEF error DEDENT                 {: RESULT = null; :}

           |    DEF:curr_def identifier:identifier_1 LPAREN typedvar_list:typedvar_1 RPAREN ARROW type:type1 COLON NEWLINE INDENT opt_declare_list:dec_list_1 stmt_list:st_list_1 DEDENT:dedent
                            {: RESULT = new FuncDef(curr_defxleft,getRight(st_list_1),identifier_1,typedvar_1,type1,dec_list_1,st_list_1); :}
           ;


/* typedvar, literals, optional declaration list, identifiers, class declaration,declare */

typedvar ::= identifier:curr_id_1 COLON type:type_1 
                    {: RESULT = new TypedVar(curr_id_1xleft,type_1xright,curr_id_1,type_1); :}
            ;


// done
literal ::=  TRUE:literal_none      {: RESULT = new BooleanLiteral(literal_nonexleft, literal_nonexright, literal_none); :}
          | FALSE:literal_none      {: RESULT = new BooleanLiteral(literal_nonexleft, literal_nonexright, literal_none); :}
          | NONE:literal_none       {: RESULT = new NoneLiteral(literal_nonexleft, literal_nonexright); :}
          | STRING:string           {: RESULT = new StringLiteral(stringxleft, stringxright, string.substring(1,string.length()-1)); :}
          | IDSTRING:id_string      {: RESULT = new StringLiteral(id_stringxleft, id_stringxright, id_string.substring(1,id_string.length()-1)); :}
          | INTEGER:integer_n       {: RESULT = new IntegerLiteral(integer_nxleft, integer_nxright, integer_n); :}
          ;

opt_declare_list ::= {: RESULT = empty(); :}
                   | opt_declare_list:declar_list declare:decl {: RESULT = combine(declar_list,decl); :}
                   ; 

identifier ::= IDENTIFIER:curr_id1   {: RESULT = new Identifier(curr_id1xleft,curr_id1xright,curr_id1); :}
             ;


class_declare ::= error                       {: RESULT=empty(); :}
                | class_declare:cl_declr error       {: RESULT = cl_declr; :}
                | class_declare:cl_declr var_def:vd  {: RESULT = combine(cl_declr,vd); :}
                | class_declare:cl_declr func_def:fd {: 
                                    if (fd!=null){
                                        RESULT=combine(cl_declr,fd);
                                    }
                                    else{
                                        RESULT=cl_declr; 
                                    }
                        
                                 
                                 :}
                | var_def:vd  {: RESULT = single(vd); :}
                | func_def:fd {: RESULT = single(fd); :}
                ;



declare ::= NONLOCAL:non_local identifier:curr_id1 NEWLINE 
                        {: RESULT = new NonLocalDecl(non_localxleft,curr_id1xright,curr_id1); :}
          | GLOBAL:curr_global identifier:curr_id1 NEWLINE 
                        {: RESULT = new GlobalDecl(curr_globalxleft,curr_id1xright,curr_id1); :}
          | func_def:curr_fd {: RESULT = curr_fd; :}
          | var_def:curr_vd  {: RESULT = curr_vd; :}
          ;

typedvar_list ::= {: RESULT = empty(); :}
                | typedvar_list:typedvar_lst COMMA error      {: RESULT = typedvar_lst; :}
                | typedvar_list:typedvar_lst COMMA typedvar:curr_typed_var {: RESULT = combine(typedvar_lst,curr_typed_var); :}
                | typedvar:curr_typed_var                       {: RESULT = single(curr_typed_var); :}                          
                ;        




type  ::= LINDEX:left_index_ type:type_1 RINDEX:right_index_ {: RESULT = new ListType(left_index_xleft,right_index_xright,type_1); :}
        | IDSTRING:curr_ids_  {: RESULT = new ClassType(curr_ids_xleft,curr_ids_xright,curr_ids_.substring(1,curr_ids_.length()-1)); :}
        | IDENTIFIER:curr_id_ {: RESULT = new ClassType(curr_id_xleft,curr_id_xright,curr_id_); :}
        ;


stmt ::= smpl_statement:curr_stmt NEWLINE {: RESULT = curr_stmt; :} 
       | IF:operation_if_ expr:expr_ COLON block:block_ elif_optional_list:elif_optional_list_
             {: RESULT = new IfStmt(operation_if_xleft, getRight(block_), expr_, block_, elif_optional_list_); :}
        | IF:operation_if_ expr:expr_ COLON block:block_
            {: RESULT = new IfStmt(operation_if_xleft, getRight(block_), expr_, block_, empty()); :}
       | FOR:for_ identifier:curr_id_ IN expr:expr_ COLON block:block_ 
             {: RESULT = new ForStmt(for_xleft, getRight(block_), curr_id_, expr_, block_); :}
       |WHILE:while_ expr:expr_ COLON block:block_ 
             {: RESULT = new WhileStmt(while_xleft, getRight(block_), expr_, block_); :}
    
       ;

elif_optional_list ::= ELIF:operator expr:expr COLON block:block elif_optional_list:elif_optional_list_  
                {: Stmt stmt = new IfStmt(operatorxleft,getRight(elif_optional_list_),expr,block,elif_optional_list_); RESULT = single(stmt); :}
                | ELIF:operator expr:expr COLON block:block  
                {: Stmt stmt =new IfStmt(operatorxleft,getRight(block),expr,block,empty()); RESULT = single(stmt); :}
                | ELSE COLON block:block {: RESULT=block; :}
                ;


block ::= NEWLINE INDENT stmt_list:stmt_list DEDENT {: RESULT = stmt_list; :} 
        ;



smpl_statement ::= expr_stmt:expr_stmt       {: RESULT = expr_stmt; :}
              | RETURN:return_            {: RESULT = new ReturnStmt(return_xleft,return_xright,null); :}
              | RETURN:return_ expr:expr  {: RESULT = new ReturnStmt(return_xleft,exprxright,expr); :}
              | assign_stmt:assign_stmt   {: RESULT = assign_stmt; :}
              | PASS                      {::}
              ;



expr_stmt ::= expr:expr {: RESULT = new ExprStmt(exprxleft, exprxright, expr); :}
            ;


assign_stmt ::= assign_targets:assign_targets EQ expr:expr 
              {: RESULT = new AssignStmt(assign_targetsxleft,exprxright,assign_targets,expr); :}
              ;


assign_targets ::= identifier:identifier                                    {: RESULT = single(identifier); :}
                 | index_expr:index_expr                                    {: RESULT = single(index_expr); :}
                 | member_expr:member_expr                                  {: RESULT = single(member_expr); :}
                 | assign_targets:assign_targets EQ index_expr:index_expr   {: RESULT = combine(assign_targets,index_expr); :}
                 | assign_targets:assign_targets EQ member_expr:member_expr {: RESULT = combine(assign_targets,member_expr); :}
                 | assign_targets:assign_targets EQ identifier:identifier   {: RESULT = combine(assign_targets,identifier); :}
                ;

expr_list ::= expr:expr                             {: RESULT = single(expr); :}
            | expr_list:expr_list COMMA error       {: RESULT = expr_list; :}
            | expr_list:expr_list COMMA expr:expr   {: RESULT = combine(expr_list,expr); :}
            |                                       {: RESULT = empty(); :}
            ;


expr ::= cexpr:c_expr                                 {: RESULT = c_expr; :}
       | expr:expr_1  AND:operator expr:expr_2        {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :} 
       | NOT:operator expr:expr                       {: RESULT = new UnaryExpr(operatorxleft,exprxright,operator,expr); :}
       | expr:expr_1 IF expr:expr_2 ELSE expr:expr_3  {: RESULT = new IfExpr(expr_1xleft,expr_3xright,expr_2,expr_1,expr_3); :} 
       | expr:expr_1  OR:operator  expr:expr_2        {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :} 
       ;

cexpr ::= tempexpr:expr {: RESULT = expr; :}
        | cexpr:expr_1 NEQ:operator  tempexpr:expr_2   {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :}
        | cexpr:expr_1 GE:operator   tempexpr:expr_2   {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :}
        | cexpr:expr_1 LT:operator   tempexpr:expr_2   {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :}
        | cexpr:expr_1 GT:operator   tempexpr:expr_2   {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :}
        | cexpr:expr_1 EQEQ:operator tempexpr:expr_2   {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :}
        | cexpr:expr_1 IS:operator   tempexpr:expr_2   {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :}
        | cexpr:expr_1 LE:operator   tempexpr:expr_2   {: RESULT = new BinaryExpr(expr_1xleft,expr_2xright,expr_1,operator,expr_2); :}
        ;

tempexpr ::= binary_expr:expre        {: RESULT = expre; :}
        | LPAREN expr:expre RPAREN {: RESULT = expre; :}
        | identifier:identifier LPAREN:lprn expr_list:expr_list RPAREN:rprn 
        {: RESULT = new CallExpr(identifierxleft, rprnxright, identifier, expr_list); :}
        | literal:literal            {: RESULT = literal; :}
        | LINDEX:lindex expr_list:expr_list RINDEX:rindex 
        {: RESULT = new ListExpr(lindexxleft, rindexxright, expr_list); :}
         | member_expr:member_expr LPAREN:lprn expr_list:expr_list RPAREN:rprn 
        {: RESULT = new MethodCallExpr(member_exprxleft, rprnxright, member_expr, expr_list); :}
        | member_expr:member_expr       {: RESULT = member_expr; :}
        | index_expr:index_expr       {: RESULT = index_expr; :}
        | identifier:identifier        {: RESULT = identifier; :}
        | MINUS:operator tempexpr:expre
        {: RESULT = new UnaryExpr(operatorxleft, exprexright, operator, expre); :}
        ;


index_expr ::= tempexpr:p_expr1 LINDEX:lindex_operator expr:p_expr2 RINDEX:rindex_operator
            {: RESULT = new IndexExpr(p_expr1xleft, rindex_operatorxright, p_expr1, p_expr2); :}
            ;


member_expr ::= tempexpr:p_expr DOT:operator identifier:identifier 
            {: RESULT = new MemberExpr(p_exprxleft, identifierxright, p_expr, identifier); :}
            ;

binary_expr ::=  tempexpr:exp_1 MULT:operator tempexpr:exp_2
                {: RESULT = new BinaryExpr(exp_1xleft,exp_2xright,exp_1,operator,exp_2); :}
              | tempexpr:exp_1 PLUS:operator tempexpr:exp_2
                    {: RESULT = new BinaryExpr(exp_1xleft,exp_2xright,exp_1,operator,exp_2); :}
              | tempexpr:exp_1 DIV:operator tempexpr:exp_2
                    {: RESULT = new BinaryExpr(exp_1xleft,exp_2xright,exp_1,operator,exp_2); :}
              | tempexpr:exp_1 MOD:operator tempexpr:exp_2
                    {: RESULT = new BinaryExpr(exp_1xleft,exp_2xright,exp_1,operator,exp_2); :}
              ;
